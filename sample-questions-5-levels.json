{
  "questions": [
    {
      "title": "Two Sum",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nExample:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].",
      "difficulty": "easy",
      "hints": ["Try using a hash map to store numbers you've seen", "For each number, check if (target - number) exists in the map"],
      "testCases": [
        {
          "input": "[2,7,11,15], 9",
          "expectedOutput": "[0,1]"
        },
        {
          "input": "[3,2,4], 6",
          "expectedOutput": "[1,2]"
        },
        {
          "input": "[3,3], 6",
          "expectedOutput": "[0,1]"
        }
      ]
    },
    {
      "title": "Valid Parentheses",
      "description": "Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nExample:\nInput: s = '()'\nOutput: true\n\nInput: s = '()[]{}'\nOutput: true\n\nInput: s = '(]'\nOutput: false",
      "difficulty": "medium",
      "hints": ["Use a stack data structure", "Push opening brackets, pop and match closing brackets"],
      "testCases": [
        {
          "input": "'()'",
          "expectedOutput": "true"
        },
        {
          "input": "'()[]{}'",
          "expectedOutput": "true"
        },
        {
          "input": "'(]'",
          "expectedOutput": "false"
        },
        {
          "input": "'([)]'",
          "expectedOutput": "false"
        },
        {
          "input": "'{[]}'",
          "expectedOutput": "true"
        }
      ]
    },
    {
      "title": "Reverse String",
      "description": "Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.\n\nExample:\nInput: s = ['h','e','l','l','o']\nOutput: ['o','l','l','e','h']",
      "difficulty": "mid-easy",
      "hints": ["Use two pointers from start and end", "Swap characters and move pointers towards center"],
      "testCases": [
        {
          "input": "['h','e','l','l','o']",
          "expectedOutput": "['o','l','l','e','h']"
        },
        {
          "input": "['H','a','n','n','a','h']",
          "expectedOutput": "['h','a','n','n','a','H']"
        }
      ]
    },
    {
      "title": "Binary Tree Maximum Path Sum",
      "description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once.\n\nThe path sum of a path is the sum of the node's values in the path.\n\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.\n\nExample:\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.",
      "difficulty": "hard",
      "hints": ["Use recursive DFS traversal", "Track max sum considering both left and right subtrees", "Handle negative values carefully"],
      "testCases": [
        {
          "input": "[1,2,3]",
          "expectedOutput": "6"
        },
        {
          "input": "[-10,9,20,null,null,15,7]",
          "expectedOutput": "42"
        }
      ]
    },
    {
      "title": "Longest Consecutive Sequence",
      "description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.\n\nExample:\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.",
      "difficulty": "mix",
      "hints": ["Use a hash set for O(1) lookups", "Only start counting from numbers that begin a sequence", "A number starts a sequence if (num - 1) doesn't exist"],
      "testCases": [
        {
          "input": "[100,4,200,1,3,2]",
          "expectedOutput": "4"
        },
        {
          "input": "[0,3,7,2,5,8,4,6,0,1]",
          "expectedOutput": "9"
        }
      ]
    }
  ]
}