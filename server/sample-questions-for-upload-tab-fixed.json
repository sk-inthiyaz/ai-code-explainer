{
  "questions": [
    {
      "title": "Find Single Number",
      "description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.",
      "difficulty": "easy",
      "category": "Arrays",
      "hints": [
        "Use XOR property: a ^ a = 0 and a ^ 0 = a",
        "Iterate once through the array and XOR all elements"
      ],
      "testCases": [
        { "input": "[2,2,1]", "expectedOutput": "1" },
        { "input": "[4,1,2,1,2]", "expectedOutput": "4" },
        { "input": "[1]", "expectedOutput": "1" }
      ]
    },
    {
      "title": "Valid Palindrome",
      "description": "Given a string s, return true if it is a palindrome, or false otherwise. Ignore non-alphanumeric characters and consider lowercase only.",
      "difficulty": "mid-easy",
      "category": "Strings",
      "hints": [
        "Use two-pointer approach from both ends",
        "Filter only alphanumeric characters before checking"
      ],
      "testCases": [
        { "input": "\"A man, a plan, a canal: Panama\"", "expectedOutput": "true" },
        { "input": "\"race a car\"", "expectedOutput": "false" },
        { "input": "\" \"", "expectedOutput": "true" }
      ]
    },
    {
      "title": "Product of Array Except Self",
      "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. You must write an algorithm that runs in O(n) and without using division.",
      "difficulty": "medium",
      "category": "Arrays",
      "hints": [
        "Use prefix and suffix product arrays",
        "Multiply prefix[i] * suffix[i] to get final result"
      ],
      "testCases": [
        { "input": "[1,2,3,4]", "expectedOutput": "[24,12,8,6]" },
        { "input": "[-1,1,0,-3,3]", "expectedOutput": "[0,0,9,0,0]" }
      ]
    },
    {
      "title": "Word Ladder",
      "description": "Given two words, beginWord and endWord, and a dictionary wordList, return the length of the shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time and each transformed word must exist in the wordList.",
      "difficulty": "hard",
      "category": "Graphs",
      "hints": [
        "Use BFS starting from beginWord",
        "For each word, generate all possible one-letter variations"
      ],
      "testCases": [
        {
          "input": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
          "expectedOutput": "5"
        },
        {
          "input": "\"hit\"\n\"cog\"\n[\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
          "expectedOutput": "0"
        }
      ]
    },
    {
      "title": "Boundary Traversal of Binary Tree",
      "description": "Given a binary tree, return the boundary traversal of the tree in an anti-clockwise direction starting from the root.",
      "difficulty": "mix",
      "category": "Trees",
      "hints": [
        "Combine left boundary, leaf nodes, and right boundary in reverse",
        "Be careful to avoid duplicates"
      ],
      "testCases": [
        { "input": "[20,8,22,4,12,null,25,10,14]", "expectedOutput": "[20,8,4,10,14,25,22]" },
        { "input": "[1,2,3,4,5,6,null,null,null,7,8]", "expectedOutput": "[1,2,4,7,8,6,3]" }
      ]
    }
  ]
}
