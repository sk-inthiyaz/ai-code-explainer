{
  "date": "2025-10-24",
  "replaceExisting": true,
  "questions": [
    {
      "title": "Reverse Integer",
      "description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.",
      "constraints": "-2^31 <= x <= 2^31 - 1",
      "hints": [
        "Consider handling negative numbers separately",
        "Use modulo and division operations to extract digits",
        "Check for integer overflow before returning"
      ],
      "functionSignature": {
        "name": "reverse",
        "params": [
          { "name": "x", "type": "int" }
        ],
        "returnType": "int"
      },
      "codeTemplate": {
        "javascript": "/**\n * @param {number} x\n * @return {number}\n */\nfunction reverse(x) {\n    // Write your solution here\n}\n",
        "python": "class Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        # Write your solution here\n        pass\n",
        "java": "class Solution {\n    public int reverse(int x) {\n        // Write your solution here\n        \n    }\n}\n",
        "cpp": "class Solution {\npublic:\n    int reverse(int x) {\n        // Write your solution here\n        \n    }\n};\n"
      },
      "testCases": [
        {
          "input": "123",
          "expectedOutput": "321",
          "explanation": "Digits reversed from 123 to 321",
          "isHidden": false
        },
        {
          "input": "-123",
          "expectedOutput": "-321",
          "explanation": "Negative number reversed",
          "isHidden": false
        },
        {
          "input": "120",
          "expectedOutput": "21",
          "explanation": "Leading zero is dropped",
          "isHidden": false
        },
        {
          "input": "1534236469",
          "expectedOutput": "0",
          "explanation": "Reversed number exceeds 32-bit integer range",
          "isHidden": true
        },
        {
          "input": "-2147483648",
          "expectedOutput": "0",
          "explanation": "Minimum 32-bit integer reversed causes overflow",
          "isHidden": true
        },
        {
          "input": "0",
          "expectedOutput": "0",
          "explanation": "Zero remains zero",
          "isHidden": true
        }
      ]
    },
    {
      "title": "Maximum Subarray",
      "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
      "constraints": "1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4",
      "hints": [
        "Use Kadane's algorithm",
        "Keep track of current sum and maximum sum",
        "Reset current sum to 0 when it becomes negative"
      ],
      "functionSignature": {
        "name": "maxSubArray",
        "params": [
          { "name": "nums", "type": "int[]" }
        ],
        "returnType": "int"
      },
      "codeTemplate": {
        "javascript": "/**\n * @param {number[]} nums\n * @return {number}\n */\nfunction maxSubArray(nums) {\n    // Write your solution here\n}\n",
        "python": "class Solution:\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # Write your solution here\n        pass\n",
        "java": "class Solution {\n    public int maxSubArray(int[] nums) {\n        // Write your solution here\n        \n    }\n}\n",
        "cpp": "class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        // Write your solution here\n        \n    }\n};\n"
      },
      "testCases": [
        {
          "input": "[-2,1,-3,4,-1,2,1,-5,4]",
          "expectedOutput": "6",
          "explanation": "[4,-1,2,1] has the largest sum = 6",
          "isHidden": false
        },
        {
          "input": "[1]",
          "expectedOutput": "1",
          "explanation": "Single element array",
          "isHidden": false
        },
        {
          "input": "[5,4,-1,7,8]",
          "expectedOutput": "23",
          "explanation": "Entire array has maximum sum",
          "isHidden": false
        },
        {
          "input": "[-1,-2,-3,-4]",
          "expectedOutput": "-1",
          "explanation": "Single element -1 is maximum",
          "isHidden": true
        },
        {
          "input": "[1,2,3,4,5]",
          "expectedOutput": "15",
          "explanation": "All positive numbers",
          "isHidden": true
        },
        {
          "input": "[1,-1,1,-1,1,-1,1]",
          "expectedOutput": "1",
          "explanation": "Multiple possible subarrays",
          "isHidden": true
        }
      ]
    },
    {
      "title": "Binary Tree Level Order Traversal",
      "description": "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
      "constraints": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
      "hints": [
        "Use breadth-first search (BFS) with a queue",
        "Track nodes level by level",
        "Consider using a delimiter or counting nodes per level"
      ],
      "functionSignature": {
        "name": "levelOrder",
        "params": [
          { "name": "root", "type": "TreeNode" }
        ],
        "returnType": "array"
      },
      "codeTemplate": {
        "javascript": "/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nfunction levelOrder(root) {\n    // Write your solution here\n}\n",
        "python": "class Solution:\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        # Write your solution here\n        pass\n",
        "java": "class Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        // Write your solution here\n        \n    }\n}\n",
        "cpp": "class Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        // Write your solution here\n        \n    }\n};\n"
      },
      "testCases": [
        {
          "input": "[3,9,20,null,null,15,7]",
          "expectedOutput": "[[3],[9,20],[15,7]]",
          "explanation": "Three levels with respective nodes",
          "isHidden": false
        },
        {
          "input": "[1]",
          "expectedOutput": "[[1]]",
          "explanation": "Single node tree",
          "isHidden": false
        },
        {
          "input": "[]",
          "expectedOutput": "[]",
          "explanation": "Empty tree",
          "isHidden": false
        },
        {
          "input": "[1,2,3,4,5,6,7]",
          "expectedOutput": "[[1],[2,3],[4,5,6,7]]",
          "explanation": "Complete binary tree",
          "isHidden": true
        },
        {
          "input": "[1,2,null,3,null,4,null,5]",
          "expectedOutput": "[[1],[2],[3],[4],[5]]",
          "explanation": "Left-skewed tree",
          "isHidden": true
        },
        {
          "input": "[1,null,2,null,3,null,4,null,5]",
          "expectedOutput": "[[1],[2],[3],[4],[5]]",
          "explanation": "Right-skewed tree",
          "isHidden": true
        }
      ]
    },
    {
      "title": "Course Schedule",
      "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [a_i, b_i] indicates that you must take course b_i first if you want to take course a_i. Return true if you can finish all courses. Otherwise, return false.",
      "constraints": "1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= a_i, b_i < numCourses\nAll prerequisite pairs are unique",
      "hints": [
        "This is a cycle detection problem in a directed graph",
        "Use topological sorting or DFS with cycle detection",
        "Consider Kahn's algorithm for topological sort"
      ],
      "functionSignature": {
        "name": "canFinish",
        "params": [
          { "name": "numCourses", "type": "int" },
          { "name": "prerequisites", "type": "int[][]" }
        ],
        "returnType": "boolean"
      },
      "codeTemplate": {
        "javascript": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nfunction canFinish(numCourses, prerequisites) {\n    // Write your solution here\n}\n",
        "python": "class Solution:\n    def canFinish(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        # Write your solution here\n        pass\n",
        "java": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        // Write your solution here\n        \n    }\n}\n",
        "cpp": "class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        // Write your solution here\n        \n    }\n};\n"
      },
      "testCases": [
        {
          "input": "2\n[[1,0]]",
          "expectedOutput": "true",
          "explanation": "Take course 0 first, then course 1",
          "isHidden": false
        },
        {
          "input": "2\n[[1,0],[0,1]]",
          "expectedOutput": "false",
          "explanation": "Cycle detected: cannot take course 0 without 1 and vice versa",
          "isHidden": false
        },
        {
          "input": "1\n[]",
          "expectedOutput": "true",
          "explanation": "No prerequisites, can finish single course",
          "isHidden": false
        },
        {
          "input": "4\n[[1,0],[2,1],[3,2]]",
          "expectedOutput": "true",
          "explanation": "Linear dependency chain, no cycles",
          "isHidden": true
        },
        {
          "input": "5\n[[1,0],[2,1],[3,4],[4,3]]",
          "expectedOutput": "false",
          "explanation": "Cycle between courses 3 and 4",
          "isHidden": true
        },
        {
          "input": "3\n[[1,0],[2,0],[2,1]]",
          "expectedOutput": "true",
          "explanation": "Multiple dependencies but no cycle",
          "isHidden": true
        }
      ]
    },
    {
      "title": "Word Search",
      "description": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
      "constraints": "m == board.length\nn == board[i].length\n1 <= m, n <= 6\n1 <= word.length <= 15\nboard and word consist of only lowercase and uppercase English letters",
      "hints": [
        "Use backtracking/DFS with pruning",
        "Mark visited cells to avoid reuse",
        "Try starting from every cell in the board",
        "Use recursion with bounds checking"
      ],
      "functionSignature": {
        "name": "exist",
        "params": [
          { "name": "board", "type": "char[][]" },
          { "name": "word", "type": "string" }
        ],
        "returnType": "boolean"
      },
      "codeTemplate": {
        "javascript": "/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nfunction exist(board, word) {\n    // Write your solution here\n}\n",
        "python": "class Solution:\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        # Write your solution here\n        pass\n",
        "java": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        // Write your solution here\n        \n    }\n}\n",
        "cpp": "class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        // Write your solution here\n        \n    }\n};\n"
      },
      "testCases": [
        {
          "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCCED\"",
          "expectedOutput": "true",
          "explanation": "Word can be formed by adjacent cells",
          "isHidden": false
        },
        {
          "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"SEE\"",
          "expectedOutput": "true",
          "explanation": "Word found in the grid",
          "isHidden": false
        },
        {
          "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]]\n\"ABCB\"",
          "expectedOutput": "false",
          "explanation": "Cannot reuse cells",
          "isHidden": false
        },
        {
          "input": "[[\"a\"]]\n\"a\"",
          "expectedOutput": "true",
          "explanation": "Single character matches",
          "isHidden": true
        },
        {
          "input": "[[\"a\",\"b\"],[\"c\",\"d\"]]\n\"abcd\"",
          "expectedOutput": "false",
          "explanation": "Cannot form word with given constraints",
          "isHidden": true
        },
        {
          "input": "[[\"C\",\"A\",\"A\"],[\"A\",\"A\",\"A\"],[\"B\",\"C\",\"D\"]]\n\"AAB\"",
          "expectedOutput": "true",
          "explanation": "Word can be formed with available adjacent cells",
          "isHidden": true
        }
      ]
    }
  ]
}